### Section 1: Setup and Loading the Universe

In this section we load the simulation using MDAnalysis. We set the Universe to a representative (middle) frame and select all Pt atoms.
import os
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import MDAnalysis as mda
from MDAnalysis.analysis.rdf import InterRDF
from scipy.signal import argrelextrema
from scipy.spatial import cKDTree
import warnings

# Suppress DeprecationWarnings for clarity
warnings.filterwarnings("ignore", category=DeprecationWarning)

# Define data parameters
data_dir = "/home/sf2/LabWork/Workspace/9-NAMDAnalysis/data"
system_name = "0HPt"
psf_file = os.path.join(data_dir, system_name, "cbs.psf")
prefix = system_name.replace("HPt", "H")
dcd_file = os.path.join(data_dir, system_name, f"{prefix}_cbs.dcd")

# Load the Universe and select the middle frame
u = mda.Universe(psf_file, dcd_file)
middle_index = len(u.trajectory) // 2
u.trajectory[middle_index]
pt_atoms = u.select_atoms("name PT*")

print(f"Loaded {len(pt_atoms)} Pt atoms from frame {middle_index}.")

### Discussion
We have now loaded the simulation and selected all 561 Pt atoms from the middle frame. This will be the basis for both our RDF and coordination number analyses.
### Section 2: Compute Averaged RDF and Determine Cutoff

In this section we compute the radial distribution function (RDF) for each Pt atom relative to all others and average the results. Then we extract the first peak and its subsequent minimum to define the cutoff distance for the first coordination shell. We also overlay a dotted red line at the cutoff on the RDF plot.
# RDF parameters
r_max = 10.0  # Maximum distance (Å)
nbins = 200

# Container for individual RDF arrays
rdf_list = []

# Loop over all Pt atoms to compute RDF for each (excluding self)
for idx in range(len(pt_atoms)):
    ref_atom = pt_atoms[idx:idx+1]        # reference atom
    other_atoms = pt_atoms - ref_atom     # all other Pt atoms
    rdf_instance = InterRDF(ref_atom, other_atoms, nbins, (0, r_max))
    rdf_instance.run(start=middle_index, stop=middle_index+1, step=1)
    rdf_list.append(rdf_instance.rdf)

# Average the RDFs over all Pt atoms
rdf_array = np.array(rdf_list)
avg_rdf = np.mean(rdf_array, axis=0)
r_bins = rdf_instance.bins  # All runs share the same binning

# Plot the averaged RDF with a dotted red line for the cutoff if found
plt.figure(figsize=(8, 5))
plt.plot(r_bins, avg_rdf, label="Averaged RDF (All Pt Atoms)")
plt.xlabel("Distance (Å)")
plt.ylabel("g(r)")
plt.title("Averaged Radial Distribution Function from All Pt Atoms")

# Find the first peak and the subsequent minimum
local_maxima = argrelextrema(avg_rdf, np.greater)[0]
if len(local_maxima) > 0:
    first_peak_index = local_maxima[0]
    print(f"First peak found at r = {r_bins[first_peak_index]:.2f} Å")
else:
    print("No local maxima found.")

local_minima = argrelextrema(avg_rdf, np.less)[0]
first_minimum_index = None
if len(local_minima) > 0:
    for idx in local_minima:
        if idx > first_peak_index:
            first_minimum_index = idx
            break

if first_minimum_index is not None:
    cutoff_distance = r_bins[first_minimum_index]
    print(f"Suggested cutoff distance (first minimum after peak): {cutoff_distance:.2f} Å")
    plt.axvline(x=cutoff_distance, color='r', linestyle='--', label="Cutoff distance")
else:
    cutoff_distance = None
    print("No suitable cutoff found from the RDF analysis.")

plt.legend()
plt.grid(True)
plt.show()

### Discussion: 
Here we loop over each Pt atom to compute its individual RDF and then average them. The averaged RDF plot now displays a dotted red vertical line at the first minimum (after the first peak), which we take as the cutoff distance for the first coordination shell. This cutoff will be used for counting neighbors in the next section.

### Section 3: Compute Coordination Numbers Using cKDTree

Using the cutoff distance from Section 2, we now build a cKDTree of the Pt atom positions and count for each atom the number of neighbors within the cutoff (subtracting one for the self-count). This yields the coordination number for each atom.
if cutoff_distance is None:
    raise ValueError("Cutoff distance was not determined. Check RDF analysis.")

# Build a cKDTree using Pt positions from the selected frame
pt_positions = pt_atoms.positions
tree = cKDTree(pt_positions)

# Calculate coordination numbers: count neighbors within the cutoff distance (excluding self)
coord_numbers = []
for pos in pt_positions:
    neighbors = tree.query_ball_point(pos, r=cutoff_distance)
    coord_numbers.append(len(neighbors) - 1)
coord_numbers = np.array(coord_numbers)

print("Coordination numbers computed for each Pt atom.")

### Discussion: 
Each Pt atom now has an associated coordination number representing the number of neighbors within the cutoff distance derived from the averaged RDF. These numbers will form the basis for our structural classification.
### Section 4: Classify Pt Atoms and Print Atom Indexes for Each Category

Based on typical coordination in a cuboctahedral Pt nanoparticle, we classify atoms as bulk, facet, edge, or vertex. We then print the atom indexes for each category and also display a histogram of the coordination numbers.
# Define classification function based on coordination number
def classify_atom(cn):
    # Typical thresholds for a cuboctahedral Pt nanoparticle:
    # Bulk: >=11; 111 facet: exactly 9; 100 facet: exactly 8; Edge: 6-7; Vertex: <6
    if cn >= 11:
        return "bulk"
    elif cn == 9:
        return "111 facet"
    elif cn == 8:
        return "100 facet"
    elif 6 <= cn < 8:
        return "edge"
    else:
        return "vertex"

# Classify each Pt atom based on its coordination number
classifications = [classify_atom(cn) for cn in coord_numbers]

# Build a DataFrame to summarize results
df_pt = pd.DataFrame({
    "atom_index": np.arange(len(pt_positions)),
    "coordination_number": coord_numbers,
    "classification": classifications
})

# Add a separate "is_surface" column: True if the atom is not bulk
df_pt["is_surface"] = df_pt["classification"] != "bulk"

# Save the DataFrame to a CSV file
output_csv = os.path.join(os.getcwd(), f"{prefix}_coordination_numbers.csv")
df_pt.to_csv(output_csv, index=False)

# Group the atom indexes by classification and also by surface (if desired)
grouped = df_pt.groupby("classification")["atom_index"].apply(list)

# Define the output file path
output_file = os.path.join(os.getcwd(), f"{prefix}_coordination_numbers.txt")

# Write the output in the desired format: 
# For each classification, write the classification name followed by a line of space-separated atom indexes.
with open(output_file, "w") as f:
    # Write classification groups
    for classification, indexes in grouped.items():
        f.write(f"{classification}\n")
        index_str = " ".join(str(idx) for idx in indexes)
        f.write(f"{index_str}\n\n")
    
    # Now, write a separate section for all surface atoms.
    surface_indexes = df_pt[df_pt["is_surface"]]["atom_index"].tolist()
    f.write("surface\n")
    surface_str = " ".join(str(idx) for idx in surface_indexes)
    f.write(f"{surface_str}\n\n")

print(f"Classification indexes saved to {output_file}")



# Print summary statistics and atom indexes for each classification
print("Summary of Pt Atom Classifications:")
summary = df_pt.groupby("classification")["atom_index"].apply(list)
print(summary)

# Optionally, plot a histogram of coordination numbers
plt.figure(figsize=(6,4))
plt.hist(coord_numbers, bins=np.arange(coord_numbers.min(), coord_numbers.max()+2)-0.5, edgecolor='black')
plt.xlabel("Coordination Number")
plt.ylabel("Frequency")
plt.title("Histogram of Pt Atom Coordination Numbers")
plt.grid(True)
plt.show()
### Discussion
In this final section we classify the Pt atoms using our computed coordination numbers. The classification thresholds are chosen based on expected values for cuboctahedral nanoparticles. The DataFrame is then grouped by classification, and we print the atom indexes for each category. This provides insight into the distribution of bulk, facets (100,111), edge, and vertex atoms in your nanoparticle. The histogram of coordination numbers further aids in visualizing the overall distribution.
